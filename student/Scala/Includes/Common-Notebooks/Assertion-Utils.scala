{"commands": [{"bindings": {}, "collapsed": false, "command": "\n//*******************************************\n// Deprecated test functions\n//*******************************************\n\ndef dbTest[T](id: String, expected: T, result: => T): Unit = {\n  val eventId = \"Test-\" + (if (id != null) id else java.util.UUID.randomUUID)\n  val evaluation = (result == expected)\n  val status = if (evaluation) \"passed\" else \"failed\"\n  daLogger.logEvent(id, s\"$eventId\\nDBTest Assertion\\n$status\\n1\")\n\n  assert(evaluation, s\"$result does not equal $expected expected\")\n}\n\n//*******************************************\n// TEST SUITE CLASSES\n//*******************************************\n\n// Test case\ncase class TestCase(description:String,\n                    testFunction:()=>Any,\n                    id:String=null,\n                    dependsOn:Seq[String]=Nil,\n                    escapeHTML:Boolean=false,\n                    points:Int=1)\n\n// Test result\ncase class TestResult(test: TestCase, skipped:Boolean = false, debug:Boolean = false) {\n  val exception: Option[Throwable] = {\n    if (skipped)\n      None\n    else if (debug) {\n      if (test.testFunction() != false)\n        None\n      else \n        Some(new AssertionError(\"Test returned false\"))\n    } else {\n      try {\n        assert(test.testFunction() != false, \"Test returned false\")\n        None\n      } catch {\n        case e: Exception => Some(e)\n        case e: AssertionError => Some(e)\n      }\n    }\n  }\n\n  val passed: Boolean = !skipped && exception.isEmpty\n\n  val message: String = {\n    exception.map(ex => {\n      val msg = ex.getMessage()\n      if (msg == null || msg.isEmpty()) ex.toString() else msg\n    }).getOrElse(\"\")\n  }\n  \n  val status: String = if (skipped) \"skipped\" else if (passed) \"passed\" else \"failed\"\n  \n  val points: Int = if (passed) test.points else 0\n}\n\nval testResultsStyle = \"\"\"\n<style>\n  table { text-align: left; border-collapse: collapse; margin: 1em; caption-side: bottom; font-family: Sans-Serif; font-size: 16px}\n  caption { text-align: left; padding: 5px }\n  th, td { border: 1px solid #ddd; padding: 5px }\n  th { background-color: #ddd }\n  .passed { background-color: #97d897 }\n  .failed { background-color: #e2716c }\n  .skipped { background-color: #f9d275 }\n  .results .points { display: none }\n  .results .message { display: none }\n  .results .passed::before  { content: \"Passed\" }\n  .results .failed::before  { content: \"Failed\" }\n  .results .skipped::before { content: \"Skipped\" }\n  .grade .passed  .message:empty::before { content:\"Passed\" }\n  .grade .failed  .message:empty::before { content:\"Failed\" }\n  .grade .skipped .message:empty::before { content:\"Skipped\" }\n</style>\n    \"\"\".trim\n\nobject TestResultsAggregator {\n  val testResults = scala.collection.mutable.Map[String,TestResult]()\n  def update(result:TestResult):TestResult = {\n    testResults.put(result.test.id, result)\n    return result\n  }\n  def score = testResults.values.map(_.points).sum\n  def maxScore = testResults.values.map(_.test.points).sum\n  def percentage = (if (maxScore == 0) 0 else 100.0 * score / maxScore).toInt\n  def displayResults():Unit = {\n    displayHTML(testResultsStyle + s\"\"\"\n    <table class='results'>\n      <tr><th colspan=\"2\">Test Summary</th></tr>\n      <tr><td>Number of Passing Tests</td><td style=\"text-align:right\">${score}</td></tr>\n      <tr><td>Number of Failing Tests</td><td style=\"text-align:right\">${maxScore-score}</td></tr>\n      <tr><td>Percentage Passed</td><td style=\"text-align:right\">${percentage}%</td></tr>\n    </table>\n    \"\"\")\n  }\n}\n\n// Test Suite\ncase class TestSuite(initialTestCases : TestCase*) {\n  \n  val testCases : scala.collection.mutable.ArrayBuffer[TestCase] = scala.collection.mutable.ArrayBuffer[TestCase]()\n  val ids : scala.collection.mutable.ArrayBuffer[String] = scala.collection.mutable.ArrayBuffer[String]()\n  \n  initialTestCases.foreach(addTest)\n  \n  import scala.collection.mutable.ListBuffer\n  import scala.xml.Utility.escape\n  \n  def runTests(debug:Boolean = false):scala.collection.mutable.ArrayBuffer[TestResult] = {\n    val failedTests = scala.collection.mutable.Set[String]()\n    val results = scala.collection.mutable.ArrayBuffer[TestResult]()\n    for (testCase <- testCases) {\n      val skip = testCase.dependsOn.exists(failedTests contains _)\n      val result = TestResult(testCase, skip, debug)\n\n      if (result.passed == false && testCase.id != null) {\n        failedTests += testCase.id\n      }\n      val eventId = \"Test-\" + (if (result.test.id != null) result.test.id \n                          else if (result.test.description != null) result.test.description.replaceAll(\"[^a-zA-Z0-9_]\", \"\").toUpperCase() \n                          else java.util.UUID.randomUUID)\n      val message = s\"${eventId}\\n${result.test.description}\\n${result.status}\\n${result.points}\"\n      daLogger.logEvent(eventId, message)\n      \n      results += result\n      TestResultsAggregator.update(result)\n    }\n    return results\n  }\n\n  lazy val testResults = runTests()\n\n  private def display(cssClass:String=\"results\", debug:Boolean=false) : Unit = {\n    val testResults = if (!debug) this.testResults else runTests(debug=true)\n    val lines = ListBuffer[String]()\n    lines += testResultsStyle\n    lines += s\"<table class='$cssClass'>\"\n    lines += \"  <tr><th class='points'>Points</th><th class='test'>Test</th><th class='result'>Result</th></tr>\"\n    for (result <- testResults) {\n      val resultHTML = s\"<td class='result ${result.status}'><span class='message'>${result.message}</span></td>\"\n      val descriptionHTML = if (result.test.escapeHTML) escape(result.test.description) else result.test.description\n      lines += s\"  <tr><td class='points'>${result.points}</td><td class='test'>$descriptionHTML</td>$resultHTML</tr>\"\n    }\n    lines += s\"  <caption class='points'>Score: $score</caption>\"\n    lines += \"</table>\"\n    val html = lines.mkString(\"\\n\")\n    displayHTML(html)\n  }\n  \n  def displayResults() : Unit = {\n    display(\"results\")\n  }\n  \n  def grade() : Int = {\n    display(\"grade\")\n    score\n  }\n  \n  def debug() : Unit = {\n    display(\"grade\", debug=true)\n  }\n  \n  def score = testResults.map(_.points).sum\n  \n  def maxScore : Integer = testCases.map(_.points).sum\n\n  def percentage = (if (maxScore == 0) 0 else 100.0 * score / maxScore).toInt\n  \n  def addTest(testCase: TestCase):TestSuite = {\n    if (testCase.id == null) throw new IllegalArgumentException(\"The test cases' id must be specified\")\n    if (ids.contains(testCase.id)) throw new IllegalArgumentException(f\"Duplicate test case id: {testCase.id}\")\n    testCases += testCase\n    ids += testCase.id\n    return this\n  }\n  \n  def test(id:String, description:String, testFunction:()=>Any, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n  \n  def testEquals(id:String, description:String, valueA:Any, valueB:Any, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> (valueA == valueB)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n  \n  def testFloats(id:String, description:String, valueA: Any, valueB: Any, tolerance: Double=0.01, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> compareFloats(valueA, valueB, tolerance)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n  \n  def testRows(id:String, description:String, rowA: org.apache.spark.sql.Row, rowB: org.apache.spark.sql.Row, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> compareRows(rowA, rowB)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n  \n  def testDataFrames(id:String, description:String, dfA:org.apache.spark.sql.DataFrame, dfB:org.apache.spark.sql.DataFrame, testColumnOrder:Boolean, testNullable:Boolean, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> compareDataFrames(dfA, dfB, testColumnOrder, testNullable)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n  \n  def testSchemas(id:String, description:String, schemaA: org.apache.spark.sql.types.StructType, schemaB: org.apache.spark.sql.types.StructType, testColumnOrder: Boolean, testNullable: Boolean, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> compareSchemas(schemaA, schemaB, testColumnOrder, testNullable)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n\n  def testContains(id:String, description:String, list:Seq[Any], value:Any, points:Int=1, dependsOn:Seq[String]=Nil, escapeHTML:Boolean=false): TestSuite = {\n    val testFunction = ()=> list.contains(value)\n    val testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return addTest(testCase)\n  }\n}\n\n//*******************************************\n// SCORE FUNCTIONS AND PLACEHOLDER GENERATION\n//*******************************************\n\ndef getQueryString(df: org.apache.spark.sql.Dataset[Row]): String = {\n  df.explain.toString\n}\n\n//*******************************************\n// Test Suite comparison functions\n//*******************************************\n\ndef compareFloats(valueA: Any, valueB: Any, tolerance: Double=0.01): Boolean = {\n  // Usage: compareFloats(valueA, valueB) (uses default tolerance of 0.01)\n  //        compareFloats(valueA, valueB, tolerance=0.001)\n  \n  import scala.math\n  try{\n       if (valueA == null && valueB == null) {\n         true\n       } else if (valueA == null || valueB == null) {\n         false\n       } else {\n         math.abs(valueA.asInstanceOf[Number].doubleValue - valueB.asInstanceOf[Number].doubleValue) <= tolerance \n       }\n  } catch {\n    case e: ClassCastException => {\n      false\n   }   \n  }\n}\n\n\ndef compareRows(rowA: org.apache.spark.sql.Row, rowB: org.apache.spark.sql.Row): Boolean = {\n  // Usage: compareRows(rowA, rowB)\n  // compares two rows as unordered Maps\n\n  if (rowA == null && rowB == null) {\n    true\n    \n  } else if (rowA == null || rowB == null) {\n    false\n    \n  // for some reason, the schema didn't make it\n  } else if (rowA.schema == null || rowB.schema == null) {\n    rowA.toSeq.toSet == rowB.toSeq.toSet\n    \n  } else {\n    rowA.getValuesMap[String](rowA.schema.fieldNames.toSeq) == rowB.getValuesMap[String](rowB.schema.fieldNames.toSeq)\n  }\n}\n\n\ndef compareDataFrames(dfA: org.apache.spark.sql.DataFrame, dfB: org.apache.spark.sql.DataFrame, testColumnOrder: Boolean, testNullable: Boolean): Boolean = {\n  if (dfA == null && dfB == null) return true\n  if (dfA == null || dfB == null) return false\n  if (compareSchemas(dfA.schema, dfB.schema, testColumnOrder, testNullable) == false) return false\n  if (dfA.count != dfB.count) return false\n\n  val rowsA = dfA.collect()\n  val rowsB = dfB.collect()\n  \n  for (i <- 0 until rowsA.length) {\n    val rowA = rowsA(i)\n    val rowB = rowsB(i)\n    for (column <- dfA.columns) {\n      val valueA = rowA.getAs[Any](column)\n      val valueB = rowB.getAs[Any](column)\n      if (valueA != valueB) return false\n    }\n  }\n  return true\n}\n\n\ndef compareSchemas(schemaA: org.apache.spark.sql.types.StructType, schemaB: org.apache.spark.sql.types.StructType, testColumnOrder: Boolean, testNullable: Boolean): Boolean = {\n  \n  if (schemaA == null && schemaB == null) return true\n  if (schemaA == null || schemaB == null) return false\n  \n  var schA = schemaA.toSeq\n  var schB = schemaB.toSeq\n\n  if (testNullable == false) {   \n    schA = schemaA.map(_.copy(nullable=true)) \n    schB = schemaB.map(_.copy(nullable=true)) \n  }\n\n  if (testColumnOrder == true) {\n    schA == schB\n  } else {\n    schA.toSet == schB.toSet\n  }\n}\n\ndisplayHTML(\"Initializing Databricks Academy's testing framework...\")\n", "commandTitle": "", "commandType": "auto", "commandVersion": 0, "commentThread": [], "commentsVisible": false, "customPlotOptions": {}, "datasetPreviewNameToCmdIdMap": {}, "diffDeletes": [], "diffInserts": [], "displayType": "table", "error": null, "errorSummary": null, "finishTime": 0, "globalVars": {}, "guid": "7cd1a5a1-fde6-4415-9c10-cd6e09842b39", "height": "auto", "hideCommandCode": false, "hideCommandResult": false, "iPythonMetadata": null, "inputWidgets": {}, "latestUser": "", "latestUserId": null, "nuid": "ce4604a9-292a-42d8-a001-9d2a91e54a9c", "origId": 0, "parentHierarchy": [], "pivotAggregation": null, "pivotColumns": null, "position": 1, "results": null, "showCommandTitle": false, "startTime": 0, "state": "finished", "streamStates": {}, "submitTime": 0, "subtype": "command", "version": "CommandV1", "width": "auto", "workflows": [], "xColumns": null, "yColumns": null}], "dashboards": [], "globalVars": {}, "guid": "24d14038-dfb1-4201-ba44-4b8d64de4a53", "iPythonMetadata": null, "inputWidgets": {}, "language": "scala", "name": "Assertion-Utils", "origId": 0, "version": "NotebookV1"}