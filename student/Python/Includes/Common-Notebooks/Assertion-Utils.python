{"commands": [{"bindings": {}, "collapsed": false, "command": "\nimport pyspark\nfrom typing import Callable, Any, Iterable, List, Set, Tuple\n\n#############################################\n# Deprecated test functions\n#############################################\n\ndef dbTest(id, expected, result):\n  import uuid\n  \n  if id: eventId = \"Test-\"+id \n  else: eventId = \"Test-\"+str(uuid.uuid1())\n\n  evaluation = str(expected) == str(result)\n  status = \"passed\" if evaluation else \"failed\"\n  daLogger.logEvent(id, f\"{eventId}\\nDBTest Assertion\\n{status}\\n1\")\n\n  assert evaluation, f\"{result} does not equal expected {expected}\"\n  \n#############################################\n# Test Suite classes\n#############################################\n\n# Test case\nclass TestCase(object):\n  __slots__=('description', 'testFunction', 'id', 'dependsOn', 'escapeHTML', 'points')\n  def __init__(self,\n               description:str,\n               testFunction:Callable[[], Any],\n               id:str=None,\n               dependsOn:Iterable[str]=[],\n               escapeHTML:bool=False,\n               points:int=1):\n    \n    self.description=description\n    self.testFunction=testFunction\n    self.id=id\n    self.dependsOn=dependsOn\n    self.escapeHTML=escapeHTML\n    self.points=points\n\n# Test result\nclass TestResult(object):\n  __slots__ = ('test', 'skipped', 'debug', 'passed', 'status', 'points', 'exception', 'message')\n  def __init__(self, test, skipped = False, debug = False):\n    try:\n      self.test = test\n      self.skipped = skipped\n      self.debug = debug\n      if skipped:\n        self.status = 'skipped'\n        self.passed = False\n        self.points = 0\n      else:\n        assert test.testFunction() != False, \"Test returned false\"\n        self.status = \"passed\"\n        self.passed = True\n        self.points = self.test.points\n      self.exception = None\n      self.message = \"\"\n    except Exception as e:\n      self.status = \"failed\"\n      self.passed = False\n      self.points = 0\n      self.exception = e\n      self.message = repr(self.exception)\n      if (debug and not isinstance(e, AssertionError)):\n        raise e\n\n# Decorator to lazy evaluate - used by TestSuite\ndef lazy_property(fn):\n    '''Decorator that makes a property lazy-evaluated.\n    '''\n    attr_name = '_lazy_' + fn.__name__\n\n    @property\n    def _lazy_property(self):\n        if not hasattr(self, attr_name):\n            setattr(self, attr_name, fn(self))\n        return getattr(self, attr_name)\n    return _lazy_property\n\n  \ntestResultsStyle = \"\"\"\n<style>\n  table { text-align: left; border-collapse: collapse; margin: 1em; caption-side: bottom; font-family: Sans-Serif; font-size: 16px}\n  caption { text-align: left; padding: 5px }\n  th, td { border: 1px solid #ddd; padding: 5px }\n  th { background-color: #ddd }\n  .passed { background-color: #97d897 }\n  .failed { background-color: #e2716c }\n  .skipped { background-color: #f9d275 }\n  .results .points { display: none }\n  .results .message { display: none }\n  .results .passed::before  { content: \"Passed\" }\n  .results .failed::before  { content: \"Failed\" }\n  .results .skipped::before { content: \"Skipped\" }\n  .grade .passed  .message:empty::before { content:\"Passed\" }\n  .grade .failed  .message:empty::before { content:\"Failed\" }\n  .grade .skipped .message:empty::before { content:\"Skipped\" }\n</style>\n    \"\"\".strip()\n\n\nclass __TestResultsAggregator(object):\n  testResults = dict()\n  \n  def update(self, result:TestResult):\n    self.testResults[result.test.id] = result\n    return result\n  \n  @lazy_property\n  def score(self) -> int:\n    return __builtins__.sum(map(lambda result: result.points, self.testResults.values()))\n  \n  @lazy_property\n  def maxScore(self) -> int:\n    return __builtins__.sum(map(lambda result: result.test.points, self.testResults.values()))\n\n  @lazy_property\n  def percentage(self) -> int:\n    return 0 if self.maxScore == 0 else int(100.0 * self.score / self.maxScore)\n\n  def displayResults(self):\n    displayHTML(testResultsStyle + f\"\"\"\n    <table class='results'>\n      <tr><th colspan=\"2\">Test Summary</th></tr>\n      <tr><td>Number of Passing Tests</td><td style=\"text-align:right\">{self.score}</td></tr>\n      <tr><td>Number of Failing Tests</td><td style=\"text-align:right\">{self.maxScore-self.score}</td></tr>\n      <tr><td>Percentage Passed</td><td style=\"text-align:right\">{self.percentage}%</td></tr>\n    </table>\n    \"\"\")\n# Lazy-man's singleton\nTestResultsAggregator = __TestResultsAggregator()\n\n\n# Test suite class\nclass TestSuite(object):\n  def __init__(self, initialTestCases: Iterable[TestCase] = None) -> None:\n    self.ids = set()\n    self.testCases = list()\n    if initialTestCases:\n      for tC in initialTestCases:\n        self.addTest(tC)\n        \n  @lazy_property\n  def testResults(self) -> List[TestResult]:\n    return self.runTests()\n  \n  def runTests(self, debug=False) -> List[TestResult]:\n    import re\n    import uuid\n    failedTests = set()\n    testResults = list()\n\n    for test in self.testCases:\n      skip = any(testId in failedTests for testId in test.dependsOn)\n      result = TestResult(test, skip, debug)\n\n      if (not result.passed and test.id != None):\n        failedTests.add(test.id)\n\n      if result.test.id: eventId = \"Test-\"+result.test.id \n      elif result.test.description: eventId = \"Test-\"+re.sub(\"[^a-zA-Z0-9_]\", \"\", result.test.description).upper()\n      else: eventId = \"Test-\"+str(uuid.uuid1())\n      message = f\"{eventId}\\n{result.test.description}\\n{result.status}\\n{result.points}\"\n      daLogger.logEvent(eventId, message)\n\n      testResults.append(result)\n      TestResultsAggregator.update(result)\n    \n    return testResults\n\n  def _display(self, cssClass:str=\"results\", debug=False) -> None:\n    from html import escape\n    testResults = self.testResults if not debug else self.runTests(debug=True)\n    lines = []\n    lines.append(testResultsStyle)\n    lines.append(\"<table class='\"+cssClass+\"'>\")\n    lines.append(\"  <tr><th class='points'>Points</th><th class='test'>Test</th><th class='result'>Result</th></tr>\")\n    for result in testResults:\n      resultHTML = \"<td class='result \"+result.status+\"'><span class='message'>\"+result.message+\"</span></td>\"\n      descriptionHTML = escape(str(result.test.description)) if (result.test.escapeHTML) else str(result.test.description)\n      lines.append(\"  <tr><td class='points'>\"+str(result.points)+\"</td><td class='test'>\"+descriptionHTML+\"</td>\"+resultHTML+\"</tr>\")\n    lines.append(\"  <caption class='points'>Score: \"+str(self.score)+\"</caption>\")\n    lines.append(\"</table>\")\n    html = \"\\n\".join(lines)\n    displayHTML(html)\n  \n  def displayResults(self) -> None:\n    self._display(\"results\")\n  \n  def grade(self) -> int:\n    self._display(\"grade\")\n    return self.score\n  \n  def debug(self) -> None:\n    self._display(\"grade\", debug=True)\n  \n  @lazy_property\n  def score(self) -> int:\n    return __builtins__.sum(map(lambda result: result.points, self.testResults))\n  \n  @lazy_property\n  def maxScore(self) -> int:\n    return __builtins__.sum(map(lambda result: result.test.points, self.testResults))\n\n  @lazy_property\n  def percentage(self) -> int:\n    return 0 if self.maxScore == 0 else int(100.0 * self.score / self.maxScore)\n\n  def addTest(self, testCase: TestCase):\n    if not testCase.id: raise ValueError(\"The test cases' id must be specified\")\n    if testCase.id in self.ids: raise ValueError(f\"Duplicate test case id: {testCase.id}\")\n    self.testCases.append(testCase)\n    self.ids.add(testCase.id)\n    return self\n  \n  def test(self, id:str, description:str, testFunction:Callable[[], Any], points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n  \n  def testEquals(self, id:str, description:str, valueA, valueB, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: valueA == valueB\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n    \n  def testFloats(self, id:str, description:str, valueA, valueB, tolerance=0.01, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: compareFloats(valueA, valueB, tolerance)\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n\n  def testRows(self, id:str, description:str, rowA: pyspark.sql.Row, rowB: pyspark.sql.Row, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: compareRows(rowA, rowB)\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n  \n  def testDataFrames(self, id:str, description:str, dfA: pyspark.sql.DataFrame, dfB: pyspark.sql.DataFrame, testColumnOrder: bool, testNullable: bool, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: compareDataFrames(dfA, dfB, testColumnOrder, testNullable)\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n  \n  def testSchemas(self, id:str, description:str, schemaA: pyspark.sql.types.StructType, schemaB: pyspark.sql.types.StructType, testColumnOrder: bool, testNullable: bool, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: compareSchemas(schemaA, schemaB, testColumnOrder, testNullable)\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n  \n  def testContains(self, id:str, description:str, listOfValues, value, points:int=1, dependsOn:Iterable[str]=[], escapeHTML:bool=False):\n    testFunction = lambda: value in listOfValues\n    testCase = TestCase(id=id, description=description, testFunction=testFunction, dependsOn=dependsOn, escapeHTML=escapeHTML, points=points)\n    return self.addTest(testCase)\n\n#############################################\n# Test Suite utilities\n#############################################\n\n\ndef getQueryString(df: pyspark.sql.DataFrame) -> str:\n  # redirect sys.stdout to a buffer\n  import sys, io\n  stdout = sys.stdout\n  sys.stdout = io.StringIO()\n\n  # call module\n  df.explain(extended=True)\n\n  # get output and restore sys.stdout\n  output = sys.stdout.getvalue()\n  sys.stdout = stdout\n\n  return output\n\n\n#############################################\n# Test Suite comparison functions\n#############################################\n\ndef compareFloats(valueA, valueB, tolerance=0.01):\n  # Usage: compareFloats(valueA, valueB) (uses default tolerance of 0.01)\n  #        compareFloats(valueA, valueB, tolerance=0.001)\n  from builtins import abs \n  \n  try:\n    if (valueA == None and valueB == None):\n         return True\n      \n    else:\n         return abs(float(valueA) - float(valueB)) <= tolerance \n      \n  except:\n    return False\n  \n  \ndef compareRows(rowA: pyspark.sql.Row, rowB: pyspark.sql.Row):\n  # Usage: compareRows(rowA, rowB)\n  # compares two Dictionaries\n  \n  if (rowA == None and rowB == None):\n    return True\n  \n  elif (rowA == None or rowB == None):\n    return False\n  \n  else: \n    return rowA.asDict() == rowB.asDict()\n\n\ndef compareDataFrames(dfA: pyspark.sql.DataFrame, dfB: pyspark.sql.DataFrame, testColumnOrder: bool, testNullable: bool):\n  if dfA == None and dfB == None: return True\n  if dfA == None or dfB == None: return False\n  if compareSchemas(dfA.schema, dfB.schema, testColumnOrder, testNullable) == False: return False\n  if dfA.count() != dfB.count(): return False\n\n  rowsA = dfA.collect()\n  rowsB = dfB.collect()\n\n  for i in range(0, len(rowsA)):\n    rowA = rowsA[i]\n    rowB = rowsB[i]\n    for column in dfA.columns:\n      valueA = rowA[column]\n      valueB = rowB[column]\n      if (valueA != valueB): return False\n\n  return True\n\n\ndef compareSchemas(schemaA: pyspark.sql.types.StructType, schemaB: pyspark.sql.types.StructType, testColumnOrder: bool, testNullable: bool): \n  \n  from pyspark.sql.types import StructField\n  \n  if (schemaA == None and schemaB == None): return True\n  if (schemaA == None or schemaB == None): return False\n  \n  schA = schemaA\n  schB = schemaB\n\n  if (testNullable == False):  \n      schA = [StructField(s.name, s.dataType, True) for s in schemaA]\n      schB = [StructField(s.name, s.dataType, True) for s in schemaB]\n\n  if (testColumnOrder == True):\n    return [schA] == [schB]\n  else:\n    return set(schA) == set(schB)\n  \ndisplayHTML(\"Initializing Databricks Academy's testing framework...\")\n", "commandTitle": "", "commandType": "auto", "commandVersion": 0, "commentThread": [], "commentsVisible": false, "customPlotOptions": {}, "datasetPreviewNameToCmdIdMap": {}, "diffDeletes": [], "diffInserts": [], "displayType": "table", "error": null, "errorSummary": null, "finishTime": 0, "globalVars": {}, "guid": "68433811-53ae-4b96-88e5-3ef42182467c", "height": "auto", "hideCommandCode": false, "hideCommandResult": false, "iPythonMetadata": null, "inputWidgets": {}, "latestUser": "", "latestUserId": null, "nuid": "37e932e6-8603-4eec-9806-d8baa3f7285e", "origId": 0, "parentHierarchy": [], "pivotAggregation": null, "pivotColumns": null, "position": 1, "results": null, "showCommandTitle": false, "startTime": 0, "state": "finished", "streamStates": {}, "submitTime": 0, "subtype": "command", "version": "CommandV1", "width": "auto", "workflows": [], "xColumns": null, "yColumns": null}], "dashboards": [], "globalVars": {}, "guid": "bfec38b3-4b2f-45c3-bf65-a21af4da0dd4", "iPythonMetadata": null, "inputWidgets": {}, "language": "python", "name": "Assertion-Utils", "origId": 0, "version": "NotebookV1"}